const { GoalNear } = require('mineflayer-pathfinder').goals;
const Vec3 = require('vec3');
const fs = require('fs');
const path = require('path');
const housesConfig = require('../config/houses');
const utils = require('./utils');
const { saveState } = require('./persistence');
const https = require('https');

const BUILD_DELAY = 400;
const ATTACK_RANGE = 16;
const ATTACK_COOLDOWN = 1000;

const ROAD_BLOCK = 'bricks';
const FILL_BLOCK = 'smooth_stone';
const LANTERN_BLOCK = 'lantern';
const LANTERN_BASE = 'stone_bricks';
const AREA_PADDING = 10;
const BUILD_SPACING = 10;

const DISCORD_WEBHOOK_URL = process.env.DISCORD_WEBHOOK_URL;

// --- Datenbank-Pfade ---
const DATA_DIR = path.join(__dirname, '../data');
const BUILDINGS_DB_FILE = path.join(DATA_DIR, 'buildings.json');
const VILLAGES_DB_FILE = path.join(DATA_DIR, 'villages.json');

function ensureDataDir() {
  try {
    if (!fs.existsSync(DATA_DIR)) {
      fs.mkdirSync(DATA_DIR, { recursive: true });
    }
  } catch (e) {
    console.error('Fehler beim Erstellen von /data:', e.message);
  }
}

function loadBuildingsDb() {
  try {
    ensureDataDir();
    if (!fs.existsSync(BUILDINGS_DB_FILE)) {
      return { buildings: [] };
    }
    const raw = fs.readFileSync(BUILDINGS_DB_FILE, 'utf8');
    const parsed = JSON.parse(raw);
    return parsed && parsed.buildings ? parsed : { buildings: [] };
  } catch (e) {
    console.warn('Fehler beim Laden von buildings.json:', e.message);
    return { buildings: [] };
  }
}

function saveBuildingsDb(db) {
  try {
    ensureDataDir();
    fs.writeFileSync(BUILDINGS_DB_FILE, JSON.stringify(db, null, 2));
  } catch (e) {
    console.warn('Fehler beim Speichern von buildings.json:', e.message);
  }
}

function isBuildingFinished(villageId, buildingIndex) {
  try {
    const db = loadBuildingsDb();
    return db.buildings && db.buildings.some(b => b.villageId === villageId && b.index === buildingIndex);
  } catch (e) {
    return false;
  }
}

function markBuildingAsFinished(villageId, buildingIndex, placement, doorRel, houseSize) {
  try {
    const db = loadBuildingsDb();
    if (!db.buildings) db.buildings = [];
    if (!db.buildings.some(b => b.villageId === villageId && b.index === buildingIndex)) {
      db.buildings.push({
        villageId,
        index: buildingIndex,
        name: placement.house?.name || 'unknown',
        x: placement.x,
        y: placement.y,
        z: placement.z,
        doorDx: doorRel.dx,
        doorDz: doorRel.dz,
        doorDy: doorRel.dy,
        width: houseSize.width,
        depth: houseSize.depth,
        finishedAt: new Date().toISOString()
      });
      saveBuildingsDb(db);
    }
  } catch (e) {
    console.warn('Fehler in markBuildingAsFinished:', e.message);
  }
}

function registerOrUpdateVillage(centerX, centerY, centerZ, houseCount) {
  try {
    const db = { villages: [] };
    try {
      if (fs.existsSync(VILLAGES_DB_FILE)) {
        const raw = fs.readFileSync(VILLAGES_DB_FILE, 'utf8');
        const parsed = JSON.parse(raw);
        db.villages = parsed.villages || [];
      }
    } catch (e) {}
    
    const villageId = `village_${centerX}_${centerY}_${centerZ}`;
    let village = db.villages.find(v => v.id === villageId);
    
    if (!village) {
      village = {
        id: villageId,
        centerX,
        centerY,
        centerZ,
        houseCount,
        createdAt: new Date().toISOString(),
        lastModified: new Date().toISOString()
      };
      db.villages.push(village);
    } else {
      village.lastModified = new Date().toISOString();
    }
    
    ensureDataDir();
    fs.writeFileSync(VILLAGES_DB_FILE, JSON.stringify(db, null, 2));
    return villageId;
  } catch (e) {
    console.warn('Fehler in registerOrUpdateVillage:', e.message);
    return `village_${centerX}_${centerY}_${centerZ}`;
  }
}

async function sendStatus(bot, message) {
  console.log("SENDSTATUS:", message);
  if (bot && typeof bot.whisper === "function" && process.env.AUTHORIZED_USER)
    bot.whisper(process.env.AUTHORIZED_USER, message);
  if (DISCORD_WEBHOOK_URL) {
    const dataObj = { content: String(message || '[NO MESSAGE]') };
    const data = JSON.stringify(dataObj);
    const url = new URL(DISCORD_WEBHOOK_URL);
    const options = {
      hostname: url.hostname,
      path: url.pathname + url.search,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(data),
        'User-Agent': 'MinecraftVillageBot'
      }
    };
    const req = https.request(options, res => {
      let body = '';
      res.on('data', chunk => { body += chunk; });
      res.on('end', () => {
        console.log('Discord Webhook response:', res.statusCode, body);
      });
    });
    req.on('error', error => {
      console.error('Fehler beim Senden des Discord Webhooks:', error);
    });
    req.write(data);
    req.end();
  }
}

async function attackNearbyMobs(bot) {
  if (!bot.entity || !bot.entities) return false;

  const mobs = Object.values(bot.entities).filter(e =>
    e.type === 'mob' &&
    e.position.distanceTo(bot.entity.position) <= ATTACK_RANGE &&
    e.position.distanceTo(bot.entity.position) > 0 &&
    e.name !== 'villager' &&
    e.name !== 'cat' &&
    e.name !== 'iron_golem'
  );

  if (mobs.length === 0) return false;

  mobs.sort((a, b) => a.position.distanceTo(bot.entity.position) - b.position.distanceTo(bot.entity.position));
  const mob = mobs[0];
  if (!mob) return false;

  try {
    await bot.lookAt(mob.position.offset(0, mob.height / 2, 0));
    bot.attack(mob);
    console.log(`‚öîÔ∏è Angriff auf Mob: ${mob.name} (${Math.round(mob.position.distanceTo(bot.entity.position))} Bl√∂cke)`);
    await utils.sleep(ATTACK_COOLDOWN);
    return true;
  } catch (e) {
    console.log(`Mob-Angriff fehlgeschlagen: ${e.message}`);
    return false;
  }
}

function findDoorInPattern(pattern) {
  for (const layer of pattern) {
    for (let dz = 0; dz < layer.blocks.length; dz++) {
      const row = layer.blocks[dz];
      for (let dx = 0; dx < row.length; dx++) {
        if (row[dx] === 'd') {
          return { dx, dz, dy: layer.y };
        }
      }
    }
  }
  const firstLayer = pattern[0] || pattern;
  return {
    dx: Math.floor((firstLayer.blocks?.[0]?.length || 7) / 2),
    dz: Math.floor(firstLayer.blocks?.length / 2 || 3),
    dy: 0
  };
}

async function safeSetBlockViaCommand(bot, pos, blockType, blockState = null) {
  let blockName = blockType;
  if (!blockName.includes('minecraft:')) blockName = `minecraft:${blockType}`;
  if (blockState) {
    blockName += `[${blockState}]`;
  }

  const targetName = blockType.replace('minecraft:', '');
  const block = bot.blockAt(pos);
  if (block && block.name === targetName) return true;

  for (let tries = 0; tries < 3; tries++) {
    bot.chat(`/setblock ${Math.floor(pos.x)} ${Math.floor(pos.y)} ${Math.floor(pos.z)} ${blockName}`);
    await utils.sleep(300);
    
    const afterBlock = bot.blockAt(pos);
    console.log(`üîç Setblock ${blockType}: Versucht=${blockName}, Server-Response=${afterBlock?.name || 'null'}`);
    
    if (afterBlock && afterBlock.name === targetName) {
      return true;
    }
  }
  
  console.warn(`‚ùå Block ${blockType} konnte nicht gesetzt werden bei ${pos.toString()}`);
  return false;
}

function detectDoorFacingAttachedOutside(bot, baseX, baseY, baseZ, doorRel) {
  const doorX = baseX + doorRel.dx;
  const doorY = baseY + doorRel.dy;
  const doorZ = baseZ + doorRel.dz;

  const northBlock = bot.blockAt(new Vec3(doorX, doorY, doorZ - 1));
  const southBlock = bot.blockAt(new Vec3(doorX, doorY, doorZ + 1));
  const westBlock = bot.blockAt(new Vec3(doorX - 1, doorY, doorZ));
  const eastBlock = bot.blockAt(new Vec3(doorX + 1, doorY, doorZ));

  if (northBlock && northBlock.name !== 'air') return 'south';
  if (southBlock && southBlock.name !== 'air') return 'north';
  if (westBlock && westBlock.name !== 'air') return 'east';
  if (eastBlock && eastBlock.name !== 'air') return 'west';
  return 'south';
}

async function flattenArea(bot, area) {
  const width = area.x2 - area.x1 + 1;
  const depth = area.z2 - area.z1 + 1;
  console.log(`üßπ R√§ume Bereich ${width}√ó${depth} bis Y=128 frei...`);

  // F√ºr gro√üe Bereiche: Schneller machen mit weniger Reads
  for (let x = area.x1; x <= area.x2; x++) {
    if (!global.botState.isBuilding) {
      console.log('‚èπÔ∏è Gel√§ndevorbereitung abgebrochen');
      return;
    }

    for (let z = area.z1; z <= area.z2; z++) {
      if (!global.botState.isBuilding) return;

      // --- PHASE 1: Unterf√ºllung (schneller mit weniger Checks) ---
      for (let yv = area.y - 16; yv < area.y; yv++) {
        if (!global.botState.isBuilding) return;
        // Blind f√ºllen ohne Check - schneller bei gro√üen Fl√§chen
        await safeSetBlockViaCommand(bot, new Vec3(x, yv, z), FILL_BLOCK);
        await utils.sleep(5); // Verk√ºrzt von 10
      }

      // --- PHASE 2: Geb√§ude-Level setzen ---
      if (!global.botState.isBuilding) return;
      await safeSetBlockViaCommand(bot, new Vec3(x, area.y, z), FILL_BLOCK);
      await utils.sleep(5);

      // --- PHASE 3: Alles √ºber dem Level entfernen (aggressive) ---
      for (let yv = area.y + 1; yv <= 128; yv++) {
        if (!global.botState.isBuilding) return;
        // Blind l√∂schen - schneller
        await safeSetBlockViaCommand(bot, new Vec3(x, yv, z), 'air');
        await utils.sleep(8);
      }
    }
  }

  if (!global.botState.isBuilding) return;

  // --- PHASE 4: Second Pass nur f√ºr Bl√∂cke die noch da sind ---
  console.log(`üßπ Second Pass f√ºr heruntergefallene Bl√∂cke...`);
  await utils.sleep(1000); // L√§ngere Wartezeit f√ºr gro√üe Fl√§chen

  for (let x = area.x1; x <= area.x2; x++) {
    if (!global.botState.isBuilding) return;
    
    for (let z = area.z1; z <= area.z2; z++) {
      if (!global.botState.isBuilding) return;

      // Nur Bl√∂cke entfernen die wirklich noch da sind
      for (let yv = area.y + 1; yv <= 128; yv++) {
        if (!global.botState.isBuilding) return;
        
        const pos = new Vec3(x, yv, z);
        const block = bot.blockAt(pos);
        
        if (block && block.name !== 'air') {
          await safeSetBlockViaCommand(bot, pos, 'air');
          await utils.sleep(8);
        } else {
          // Wenn Luft, nicht mehr pr√ºfen (Performance)
          break;
        }
      }
    }
  }

  console.log('‚úÖ Gel√§ndevorbereitung abgeschlossen');
}


async function buildRoad(bot, buildingX, buildingZ, doorRel, houseWidth, houseDepth, centerX, centerZ, y) {
  const roadY = y;
  
  // T√ºr-Position
  const doorX = buildingX + doorRel.dx;
  const doorZ = buildingZ + doorRel.dz;

  // Geb√§ude-Grenzen (mit 2 Block Abstand)
  const minX = buildingX - Math.floor(houseWidth / 2) - 2;
  const maxX = buildingX + Math.floor(houseWidth / 2) + 2;
  const minZ = buildingZ - Math.floor(houseDepth / 2) - 2;
  const maxZ = buildingZ + Math.floor(houseDepth / 2) + 2;

  console.log(`üõ£Ô∏è Baue Stra√üe von T√ºr (${doorX}, ${doorZ}) zum Zentrum (${centerX}, ${centerZ})`);

  // Starte 2 Bl√∂cke neben der T√ºr
  let x, z;
  
  if (Math.abs(doorX - centerX) > Math.abs(doorZ - centerZ)) {
    x = doorX + (doorX < centerX ? -2 : 2);
    z = doorZ;
  } else {
    x = doorX;
    z = doorZ + (doorZ < centerZ ? -2 : 2);
  }

  let steps = 0;

  while (x !== centerX || z !== centerZ) {
    // STOP-Pr√ºfung HIER
    if (!global.botState.isBuilding) {
      console.log('‚èπÔ∏è Stra√üenbau abgebrochen');
      return;
    }

    await attackNearbyMobs(bot);

    const moveX = Math.abs(centerX - x) > Math.abs(centerZ - z) ? Math.sign(centerX - x) : 0;
    const moveZ = Math.abs(centerZ - z) > Math.abs(centerX - x) ? Math.sign(centerZ - z) : 0;

    let nextX = x + moveX;
    let nextZ = z + moveZ;

    if (!(nextX >= minX && nextX <= maxX && nextZ >= minZ && nextZ <= maxZ)) {
      x = nextX;
      z = nextZ;

      // STOP-Pr√ºfung VOR Blockplatzierung
      if (!global.botState.isBuilding) return;

      if (moveX !== 0 && moveZ !== 0) {
        // Diagonale: 4 Bl√∂cke breit
        await safeSetBlockViaCommand(bot, new Vec3(x, roadY, z), ROAD_BLOCK);
        await safeSetBlockViaCommand(bot, new Vec3(x + 1, roadY, z), ROAD_BLOCK);
        await safeSetBlockViaCommand(bot, new Vec3(x, roadY, z + 1), ROAD_BLOCK);
        await safeSetBlockViaCommand(bot, new Vec3(x + 1, roadY, z + 1), ROAD_BLOCK);

        for (let yv = roadY + 1; yv <= roadY + 4; yv++) {
          if (!global.botState.isBuilding) return;
          await safeSetBlockViaCommand(bot, new Vec3(x, yv, z), 'air');
          await safeSetBlockViaCommand(bot, new Vec3(x + 1, yv, z), 'air');
          await safeSetBlockViaCommand(bot, new Vec3(x, yv, z + 1), 'air');
          await safeSetBlockViaCommand(bot, new Vec3(x + 1, yv, z + 1), 'air');
          await utils.sleep(10);
        }
      } else {
        // Gerade: 2 Bl√∂cke breit
        await safeSetBlockViaCommand(bot, new Vec3(x, roadY, z), ROAD_BLOCK);
        await safeSetBlockViaCommand(bot, new Vec3(x + 1, roadY, z), ROAD_BLOCK);

        for (let yv = roadY + 1; yv <= roadY + 4; yv++) {
          if (!global.botState.isBuilding) return;
          await safeSetBlockViaCommand(bot, new Vec3(x, yv, z), 'air');
          await safeSetBlockViaCommand(bot, new Vec3(x + 1, yv, z), 'air');
          await utils.sleep(10);
        }
      }

      // Laternen
      if (steps % 6 === 0) {
        const lx = x + 2, lz = z;
        const grassPos = new Vec3(lx, roadY - 1, lz);
        const abovePos = new Vec3(lx, roadY, lz);
        const blockBelow = bot.blockAt(grassPos);
        const blockAbove = bot.blockAt(abovePos);
        if (blockBelow && blockBelow.name === LANTERN_BASE &&
          (blockAbove.name === 'air' || blockAbove.name === 'cave_air')) {
          await safeSetBlockViaCommand(bot, grassPos, LANTERN_BASE);
          await safeSetBlockViaCommand(bot, abovePos, LANTERN_BLOCK);
        }
      }
    } else {
      // Ausweichlogik
      if (moveX !== 0 && moveZ === 0) {
        nextZ = z + Math.sign(centerZ - z);
        if (!(nextX >= minX && nextX <= maxX && nextZ >= minZ && nextZ <= maxZ)) {
          z = nextZ;
        } else {
          x = nextX;
        }
      } else if (moveX === 0 && moveZ !== 0) {
        nextX = x + Math.sign(centerX - x);
        if (!(nextX >= minX && nextX <= maxX && nextZ >= minZ && nextZ <= maxZ)) {
          x = nextX;
        } else {
          z = nextZ;
        }
      }
    }

    steps++;
    await utils.sleep(20);
  }

  console.log(`‚úÖ Stra√üe komplett`);
}


async function positionBotForDoor(bot, baseX, baseY, baseZ, doorRel, facing) {
  const doorX = baseX + doorRel.dx;
  const doorY = baseY + doorRel.dy + 1;
  const doorZ = baseZ + doorRel.dz;

  let botX, botZ;

  switch (facing) {
    case 'north': botX = doorX; botZ = doorZ + 3; break;
    case 'south': botX = doorX; botZ = doorZ - 3; break;
    case 'east': botX = doorX - 3; botZ = doorZ; break;
    case 'west': botX = doorX + 3; botZ = doorZ; break;
    default: botX = doorX; botZ = doorZ + 3;
  }

  if (bot.game && bot.game.gameMode === 1) {
    bot.entity.position.set(botX, doorY, botZ);
  } else {
    try {
      await bot.pathfinder.goto(new GoalNear(botX, doorY, botZ, 1));
    } catch (e) {
      console.log('Bot-Bewegung zur T√ºr fehlgeschlagen');
    }
  }

  await utils.sleep(500);
  console.log(`ü§ñ Bot positioniert vor T√ºr bei ${botX},${doorY},${botZ} (facing=${facing})`);
}

async function clearPathForDoor(bot, baseX, baseY, baseZ, doorRel) {
  const doorX = baseX + doorRel.dx;
  const doorY = baseY + doorRel.dy;
  const doorZ = baseZ + doorRel.dz;

  for (let x = doorX - 2; x <= doorX + 2; x++) {
    for (let y = doorY - 1; y <= doorY + 3; y++) {
      for (let z = doorZ - 2; z <= doorZ + 2; z++) {
        const pos = new Vec3(x, y, z);
        const block = bot.blockAt(pos);
        if (block && block.name !== 'air') {
          await safeSetBlockViaCommand(bot, pos, 'air');
          await utils.sleep(50);
        }
      }
    }
  }
}

async function canPlaceDoor(bot, baseX, baseY, baseZ, doorRel) {
  const lowerY = baseY + doorRel.dy;
  const upperY = lowerY + 1;
  const leftLower = bot.blockAt(new Vec3(baseX + doorRel.dx - 1, lowerY, baseZ + doorRel.dz));
  const rightLower = bot.blockAt(new Vec3(baseX + doorRel.dx + 1, lowerY, baseZ + doorRel.dz));
  const leftUpper = bot.blockAt(new Vec3(baseX + doorRel.dx - 1, upperY, baseZ + doorRel.dz));
  const rightUpper = bot.blockAt(new Vec3(baseX + doorRel.dx + 1, upperY, baseZ + doorRel.dz));

  return (
    leftLower && leftLower.name !== 'air' &&
    rightLower && rightLower.name !== 'air' &&
    leftUpper && leftUpper.name !== 'air' &&
    rightUpper && rightUpper.name !== 'air'
  );
}

async function placeDoor(bot, baseX, baseY, baseZ, doorRel, doorMaterial, facing) {
  const doorX = baseX + doorRel.dx;
  const doorY = baseY + doorRel.dy;
  const doorZ = baseZ + doorRel.dz;

  const lowerState = `facing=${facing},half=lower,hinge=left,open=false,powered=false`;
  const upperState = `facing=${facing},half=upper,hinge=left,open=false,powered=false`;

  const lowerPos = new Vec3(doorX, doorY, doorZ);
  const upperPos = new Vec3(doorX, doorY + 1, doorZ);

  await safeSetBlockViaCommand(bot, lowerPos, 'air');
  await safeSetBlockViaCommand(bot, upperPos, 'air');
  await utils.sleep(150);

  const lowerSuccess = await safeSetBlockViaCommand(bot, lowerPos, doorMaterial, lowerState);
  await utils.sleep(150);
  const upperSuccess = await safeSetBlockViaCommand(bot, upperPos, doorMaterial, upperState);

  console.log(`üö™ T√ºr gesetzt: lower=${lowerSuccess}, upper=${upperSuccess} (facing=${facing})`);
  return lowerSuccess && upperSuccess;
}

function setupChatHandler(bot) {
  bot.on('chat', (username, message) => {
    if (username === bot.username) return;

    const authorizedUsers = ['derlemue', '[Server]', 'Server'];
    if (!authorizedUsers.includes(username)) return;

    console.log(`[CHAT-${username}] ${message}`);
    const msgLower = message.toLowerCase().trim();

    if (msgLower === '!help') {
      bot.chat('üÜò Befehle: !explore | !build x y z N | !stop | !status | !help');
      return;
    }

    if (msgLower === '!explore') {
      global.botState.isExploring = true;
      global.botState.isBuilding = false;
      saveState(global.botState);
      bot.chat('üß≠ Starte Kartenerkundung');
      return;
    }

    if (msgLower.startsWith('!build ')) {
      const parts = message.trim().split(' ');
      if (parts.length === 5) {
        const x = parseInt(parts[1]);
        const y = parseInt(parts[2]);
        const z = parseInt(parts[3]);
        const N = parseInt(parts[4]);
        if (!isNaN(x) && !isNaN(y) && !isNaN(z) && !isNaN(N)) {
          global.botState.isBuilding = true;
          global.botState.isExploring = false;
          global.botState.buildCoords = { x, y, z };
          global.botState.buildHouseCount = N;
          saveState(global.botState);
          bot.chat(`üèóÔ∏è Starte Dorfbau bei (${x}, ${y}, ${z}) mit ${N} Geb√§uden`);
          setTimeout(() => {
            bot.emit('buildVillage', x, y, z, N);
          }, 1000);
          return;
        }
      }
      bot.chat('‚ùå !build x y z N (z.B. !build 100 64 100 50)');
      return;
    }

    if (msgLower === '!stop') {
      global.botState.isBuilding = false;
      global.botState.isExploring = false;
      saveState(global.botState);
      bot.chat('‚èπÔ∏è Stoppe Erkundung');
      return;
    }

    if (msgLower === '!status') {
      let statusMsg = '';
      if (global.botState.isBuilding) {
        statusMsg = `üèóÔ∏è BAUEND: Geb√§ude ${global.botState.buildIndex || 0}/${global.botState.buildHouseCount || '?'} bei (${global.botState.buildCoords?.x || '?'}, ${global.botState.buildCoords?.y || '?'}, ${global.botState.buildCoords?.z || '?'})`;
      } else if (global.botState.isExploring) {
        statusMsg = 'üß≠ ERKUNDUNG: Aktiv';
      } else {
        statusMsg = '‚è∏Ô∏è INAKTIV';
      }
      bot.chat(statusMsg);
      console.log(`Status abgefragt: ${statusMsg}`);
      return;
    }
  });

  console.log('‚úÖ Chat-Handler eingerichtet - Befehle: !explore, !build x y z N, !stop, !status, !help');
}

module.exports = {
  setupChatHandler,

  async buildVillage(bot, centerX, centerY, centerZ, houseCount) {
    if (bot.game && bot.game.gameMode === 1) {
      bot.entity.position.set(centerX, centerY + 2, centerZ);
    } else {
      try {
        await bot.pathfinder.goto(new GoalNear(centerX, centerY + 2, centerZ, 2));
      } catch {
        console.log('Bewegung zum Bauzentrum fehlgeschlagen');
      }
    }

    houseCount = houseCount || utils.randomInt(30, 90);
    const villageId = registerOrUpdateVillage(centerX, centerY, centerZ, houseCount);
    
    if (!global.botState.buildCoords ||
      global.botState.buildCoords.x !== centerX ||
      global.botState.buildCoords.y !== centerY ||
      global.botState.buildCoords.z !== centerZ) {
      global.botState.buildIndex = 0;
      global.botState.buildHouseCount = houseCount;
      global.botState.buildCoords = { x: centerX, y: centerY, z: centerZ };
      saveState(global.botState);
    }

    await sendStatus(bot, `üèóÔ∏è Starte Dorfbau bei (${centerX}, ${centerY}, ${centerZ}) mit ${houseCount} Geb√§uden`);
    const placements = this.planVillageLayout(centerX, centerY, centerZ, houseCount);
    const levelY = centerY;

    for (let i = global.botState.buildIndex || 0; i < placements.length; i++) {
      if (!global.botState.isBuilding) break;

      if (isBuildingFinished(villageId, i)) {
        console.log(`‚è≠Ô∏è Geb√§ude ${i + 1} von ${placements.length} √ºbersprungen (bereits fertig)`);
        continue;
      }

      if (bot.game && bot.game.gameMode === 1) {
        bot.entity.position.set(placements[i].x, levelY + 2, placements[i].z);
        await utils.sleep(200);
      } else {
        try {
          await bot.pathfinder.goto(new GoalNear(placements[i].x, levelY + 2, placements[i].z, 2));
        } catch {
          console.log('Bewegung zur Baustelle fehlgeschlagen');
        }
      }

      await attackNearbyMobs(bot);

      const info = `üèóÔ∏è Baue Geb√§ude ${i + 1} von ${placements.length}: ${placements[i].house.name}`;
      console.log(info);
      await sendStatus(bot, info);

      const g = placements[i].house;
      const area = utils.areaCoords(
        placements[i].x, levelY,
        placements[i].z,
        (g.width || 7) + AREA_PADDING,
        (g.depth || g.length || 7) + AREA_PADDING
      );

    console.log(`üì¶ Lade Chunks f√ºr Baustelle...`);
    try {
      const chunkX = Math.floor(placements[i].x / 16);
      const chunkZ = Math.floor(placements[i].z / 16);
      
      // Warte bis Chunks geladen sind
      for (let cx = chunkX - 2; cx <= chunkX + 2; cx++) {
        for (let cz = chunkZ - 2; cz <= chunkZ + 2; cz++) {
          const chunk = bot.world.getChunk(cx, cz);
          if (!chunk) {
            console.log(`‚è≥ Chunk (${cx}, ${cz}) noch nicht geladen...`);
            await utils.sleep(500);
          }
        }
      }
      console.log(`‚úÖ Alle Chunks geladen`);
    } catch (e) {
      console.warn('Chunk-Laden fehlgeschlagen:', e.message);
    }

      await flattenArea(bot, area);
      if (!global.botState.isBuilding) break;

      const success = await this.buildStructure(bot, placements[i].x, levelY, placements[i].z, g, i + 1, placements.length);
      if (!global.botState.isBuilding) break;

      if (success) {
        const doorRel = findDoorInPattern(g.pattern);
        const houseSize = { width: g.width || 7, depth: g.depth || g.length || 7 };
        
        markBuildingAsFinished(villageId, i, placements[i], doorRel, houseSize);

        global.botState.buildIndex = i + 1;
        saveState(global.botState);

        const doneMsg = `‚úÖ Geb√§ude ${i + 1} von ${placements.length} fertig gebaut (${placements[i].house.name})`;
        await sendStatus(bot, doneMsg);

        // Stra√üe nach Geb√§ude
        await buildRoad(bot, placements[i].x, placements[i].z, doorRel, houseSize.width, houseSize.depth, centerX, centerZ, levelY);
        
        if (!global.botState.isBuilding) break;
      }

      if (!global.botState.isBuilding) break;
      await utils.sleep(5000);
    }

    await sendStatus(bot, '‚úÖ Dorfbau abgeschlossen');
    global.botState.isBuilding = false;
    global.botState.buildIndex = null;
    global.botState.buildHouseCount = null;
    saveState(global.botState);
  },

  planVillageLayout(centerX, centerY, centerZ, houseCount) {
    const placements = [];
    const spacing = housesConfig.villageLayout?.spacing || 8;
    const houses = housesConfig.villageHouses?.filter(h => h.profession !== 'decoration') || [];
    let placed = 0, attempts = 0;

    while (placed < houseCount && attempts < houseCount * 10) {
      const angle = Math.random() * Math.PI * 2;
      const radius = spacing + placed * (BUILD_SPACING + 5);
      const x = Math.floor(centerX + radius * Math.cos(angle));
      const z = Math.floor(centerZ + radius * Math.sin(angle));
      const y = centerY;

      let minDist = Infinity;
      for (const existing of placements) {
        const dist = Math.hypot(x - existing.x, z - existing.z);
        if (dist < minDist) minDist = dist;
      }

      if (minDist < BUILD_SPACING + 5) {
        attempts++;
        continue;
      }

      const house = houses[utils.randomInt(0, houses.length - 1)] || houses[0];
      placements.push({ x, y, z, house });
      placed++;
    }
    return placements;
  },

  async buildStructure(bot, x, y, z, houseConfig, idx, total) {
    await attackNearbyMobs(bot);
    const doorRel = findDoorInPattern(houseConfig.pattern);

    let blocksPlaced = 0;
    for (const layer of houseConfig.pattern) {
      for (let dz = 0; dz < layer.blocks.length; dz++) {
        if (!global.botState.isBuilding) return false;
        const row = layer.blocks[dz];
        for (let dx = 0; dx < row.length; dx++) {
          if (!global.botState.isBuilding) return false;
          const symbol = row[dx];
          if (symbol === 'd') continue;
          if (symbol !== '.') {
            const materialName = houseConfig.materials[symbol];
            if (!materialName) continue;
            const blockPos = new Vec3(x + dx, y + layer.y, z + dz);
            await safeSetBlockViaCommand(bot, blockPos, materialName);
            await utils.sleep(BUILD_DELAY);
            blocksPlaced++;
            if (blocksPlaced % 15 === 0) {
              await attackNearbyMobs(bot);
            }
          }
        }
      }
    }

    let doorPlaced = false;
    const doorMaterial = houseConfig.materials['d'] || 'oak_door';

    for (let doorAttempt = 0; doorAttempt < 3 && !doorPlaced; doorAttempt++) {
      await attackNearbyMobs(bot);

      if (await canPlaceDoor(bot, x, y, z, doorRel)) {
        const facing = detectDoorFacingAttachedOutside(bot, x, y, z, doorRel);
        await positionBotForDoor(bot, x, y, z, doorRel, facing);
        await clearPathForDoor(bot, x, y, z, doorRel);
        doorPlaced = await placeDoor(bot, x, y, z, doorRel, doorMaterial, facing);
      } else {
        console.log(`‚è≥ T√ºrrahmen noch nicht bereit (Versuch ${doorAttempt + 1}/3)`);
        await utils.sleep(2000);
      }
    }

    return true;
  }
};

